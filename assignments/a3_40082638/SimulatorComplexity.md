#### What is the Big-O (O(n)) and Big-Omega (Î©(n)) time complexity for each of the implemented priority queues in terms of MaxNumberOfJobs? explain.
My priority queues both use sorted arrays for their implementations, so every time you insert, you need to find the correct position to insert it into. Therefore, the time complexity for insertion for both of them is $O(n)$. The time complexity for deletion from both of them is going to be the same as well, because on deletion we then need to shift the entire array over to compensate for the deleted element. The time complexity for deletion is going to be $O(n)$. Retrieving the first element from both is going to be an $O(1)$ operation since the arrays are both sorted. 

#### What is the space complexity of each of the implemented priority queues in terms of MaxNumberOfJobs? explain.
The space complexity of both is going to be $O(n)$. For each insertion, you need to shift over the entire array, which is going to be $O(n)$ space complexity because you need to copy the entire array. Both are going to be $O(n)$ space complexity for removal as well, because whenever you remove it will always be from the front since it's sorted, therefore you need to shift over the entire array. Peeking at the top element will remain $O(1)$.

#### Is there a performance difference between the different implementations? Is the difference significant (i.e. in terms of increased % of time)? If so, explain why; if not, explain why in the end all these implementations produce comparable results.
Since my implementations are both using arrays, not doubly linked lists, we have the same core problems with the underlying data structure. Adding is always going to be an O(n) operation since you need to shift elements over, and removing is going to be the same since we need to either rebalance or shift everything over. So the performance difference isn't going to be significant for the two of them. 